{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./compPrincipal/producto/productos.service\";\nexport class ListaProductoService {\n  constructor(http, productoService) {\n    this.http = http;\n    this.productoService = productoService;\n    this.productos = [];\n    this.productoSeleccionado = null;\n    this.apiUrl = 'http://localhost:8080/producto/editar';\n  }\n  getListaProductos() {\n    return this.productos;\n  }\n  editarProducto(producto) {\n    // Guarda el producto seleccionado para editarlo\n    this.productoSeleccionado = {\n      ...producto\n    };\n    console.log(this.productoSeleccionado);\n    this.productoService.editarProducto(this.productoSeleccionado.id, this.productoSeleccionado).subscribe({\n      next: () => {\n        console.log('Producto editado exitosamente');\n        // Puedes realizar acciones adicionales después de la edición si es necesario\n      },\n\n      error: error => {\n        console.error('Error al editar el producto:', error);\n        // Manejo de errores\n      }\n    });\n  }\n\n  guardarProducto(producto) {\n    const url = `${this.apiUrl}/${producto.id}`;\n    console.log(url);\n    // Crea un objeto del tipo RequestBody\n    const body = {};\n    // Asigna valores a las propiedades si existen en el objeto producto\n    if (producto.codigo !== undefined) {\n      body.codigo = producto.codigo;\n    }\n    if (producto.nombre !== undefined) {\n      body.nombre = producto.nombre;\n    }\n    if (producto.descripcion !== undefined) {\n      body.descripcion = producto.descripcion;\n    }\n    // Realiza la solicitud PUT con el cuerpo construido\n    return this.http.put(url, body);\n  }\n  static #_ = this.ɵfac = function ListaProductoService_Factory(t) {\n    return new (t || ListaProductoService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.ProductosService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ListaProductoService,\n    factory: ListaProductoService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["ListaProductoService","constructor","http","productoService","productos","productoSeleccionado","apiUrl","getListaProductos","editarProducto","producto","console","log","id","subscribe","next","error","guardarProducto","url","body","codigo","undefined","nombre","descripcion","put","_","i0","ɵɵinject","i1","HttpClient","i2","ProductosService","_2","factory","ɵfac","providedIn"],"sources":["C:\\Users\\SIMM\\Desktop\\Nueva carpeta\\Desarrollo-de-software\\Proyecto-Catedra-Desarrollo-de-Software-front--master\\src\\app\\lista-producto.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Producto } from './compPrincipal/interfaces/Producto';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { ProductosService } from './compPrincipal/producto/productos.service';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ListaProductoService {\n  \n  private productos: Producto[] = [];\n  productoSeleccionado: Producto | null = null;\n\n  private apiUrl = 'http://localhost:8080/producto/editar';\n\n  constructor(private http: HttpClient, private productoService: ProductosService) { }\n\n  getListaProductos(): Producto[] {\n    return this.productos;\n  }\n\n  editarProducto(producto: Producto): void {\n    // Guarda el producto seleccionado para editarlo\n    this.productoSeleccionado = { ...producto };\n    console.log(this.productoSeleccionado);\n  \n    this.productoService.editarProducto(this.productoSeleccionado.id, this.productoSeleccionado)\n      .subscribe({\n        next: () => {\n          console.log('Producto editado exitosamente');\n          // Puedes realizar acciones adicionales después de la edición si es necesario\n        },\n        error: (error) => {\n          console.error('Error al editar el producto:', error);\n          // Manejo de errores\n        }\n      });\n  }\n  \n\n  guardarProducto(producto: Producto): Observable<any> {\n    const url = `${this.apiUrl}/${producto.id}`;\n    console.log(url);\n  \n    // Define un tipo para el cuerpo de la solicitud\n    interface RequestBody {\n      codigo?: number;\n      nombre?: string;\n      descripcion?: string;\n    }\n  \n    // Crea un objeto del tipo RequestBody\n    const body: RequestBody = {};\n  \n    // Asigna valores a las propiedades si existen en el objeto producto\n    if (producto.codigo !== undefined) {\n      body.codigo = producto.codigo;\n    }\n  \n    if (producto.nombre !== undefined) {\n      body.nombre = producto.nombre;\n    }\n  \n    if (producto.descripcion !== undefined) {\n      body.descripcion = producto.descripcion;\n    }\n  \n    // Realiza la solicitud PUT con el cuerpo construido\n    return this.http.put(url, body);\n  }\n\n\n  /*\n  Guardar sin backend\n  guardarProducto(): void {\n    const updatedProducts = this.productos.map(product => {\n      return product.id === this.productoSeleccionado?.id ? { ...this.productoSeleccionado } : product;\n    });\n    //console.log(updatedProducts);\n    this.productos = [...updatedProducts];\n    this.productoSeleccionado = null;\n  }*/\n}\n\n/*\nthis.productos.map(product => {...}): This uses the map function to create a new array by iterating over each element (product) in the existing this.productos array.\n\nproduct.id === this.productoSeleccionado?.id ? { ...this.productoSeleccionado } : product: For each product, it checks if the id of the current product matches the id of this.productoSeleccionado.\n\nIf the IDs match, it returns a new object { ...this.productoSeleccionado }, which is a shallow copy of the this.productoSeleccionado object. This ensures that the original array remains immutable, and only the selected product is replaced with the updated one.\nIf the IDs do not match, it returns the original product unchanged.\n\nthis.productos = [...updatedProducts]: This line updates the original this.productos array with the new array (updatedProducts). \nBy assigning this new array to this.productos, you effectively update the original array with the modified product.\nthis.productoSeleccionado = null;: Finally, this line sets this.productoSeleccionado to null, indicating that there is no longer a selected product. \n*/\n"],"mappings":";;;AAUA,OAAM,MAAOA,oBAAoB;EAO/BC,YAAoBC,IAAgB,EAAUC,eAAiC;IAA3D,KAAAD,IAAI,GAAJA,IAAI;IAAsB,KAAAC,eAAe,GAAfA,eAAe;IALrD,KAAAC,SAAS,GAAe,EAAE;IAClC,KAAAC,oBAAoB,GAAoB,IAAI;IAEpC,KAAAC,MAAM,GAAG,uCAAuC;EAE2B;EAEnFC,iBAAiBA,CAAA;IACf,OAAO,IAAI,CAACH,SAAS;EACvB;EAEAI,cAAcA,CAACC,QAAkB;IAC/B;IACA,IAAI,CAACJ,oBAAoB,GAAG;MAAE,GAAGI;IAAQ,CAAE;IAC3CC,OAAO,CAACC,GAAG,CAAC,IAAI,CAACN,oBAAoB,CAAC;IAEtC,IAAI,CAACF,eAAe,CAACK,cAAc,CAAC,IAAI,CAACH,oBAAoB,CAACO,EAAE,EAAE,IAAI,CAACP,oBAAoB,CAAC,CACzFQ,SAAS,CAAC;MACTC,IAAI,EAAEA,CAAA,KAAK;QACTJ,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;QAC5C;MACF,CAAC;;MACDI,KAAK,EAAGA,KAAK,IAAI;QACfL,OAAO,CAACK,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;QACpD;MACF;KACD,CAAC;EACN;;EAGAC,eAAeA,CAACP,QAAkB;IAChC,MAAMQ,GAAG,GAAG,GAAG,IAAI,CAACX,MAAM,IAAIG,QAAQ,CAACG,EAAE,EAAE;IAC3CF,OAAO,CAACC,GAAG,CAACM,GAAG,CAAC;IAShB;IACA,MAAMC,IAAI,GAAgB,EAAE;IAE5B;IACA,IAAIT,QAAQ,CAACU,MAAM,KAAKC,SAAS,EAAE;MACjCF,IAAI,CAACC,MAAM,GAAGV,QAAQ,CAACU,MAAM;;IAG/B,IAAIV,QAAQ,CAACY,MAAM,KAAKD,SAAS,EAAE;MACjCF,IAAI,CAACG,MAAM,GAAGZ,QAAQ,CAACY,MAAM;;IAG/B,IAAIZ,QAAQ,CAACa,WAAW,KAAKF,SAAS,EAAE;MACtCF,IAAI,CAACI,WAAW,GAAGb,QAAQ,CAACa,WAAW;;IAGzC;IACA,OAAO,IAAI,CAACpB,IAAI,CAACqB,GAAG,CAACN,GAAG,EAAEC,IAAI,CAAC;EACjC;EAAC,QAAAM,CAAA,G;qBA7DUxB,oBAAoB,EAAAyB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA,GAAAH,EAAA,CAAAC,QAAA,CAAAG,EAAA,CAAAC,gBAAA;EAAA;EAAA,QAAAC,EAAA,G;WAApB/B,oBAAoB;IAAAgC,OAAA,EAApBhC,oBAAoB,CAAAiC,IAAA;IAAAC,UAAA,EAFnB;EAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}